[TOC]

```
1. 本书从2016.12.18开始阅读。
2. 本书所有练习代码都在GitHub上维护。地址：https://github.com/FanZhouk/Algorithm.git
3. 笔记使用Typora编写，在GitHub上会有公式无法显示的问题。
```

# 第一章 基础

## 1.1 基础编程模型

## 1.2 数据抽象

抽象数据类型（ADT），开发中会碰到很多种抽象数据类型，涉及数学的比如整数、浮点数，涉及数据结构的比如数组、链表，与现实相关的比如日期（Date）等。

使用抽象数据类型的好处在于，我们使用这些ADT的时候是面向接口编程的，即我们可以将一种实现改变为另一种实现，而无需改变调用部分的代码。

## 1.3 背包、队列和栈

**背包**：是一种不支持删除元素的集合数据类型，它的目的就是帮助用例收集元素，并迭代遍历所有收集到的元素。使用背包就说明，元素的处理顺序不重要。可以想象一个背包，往里面放了n个小球，取出的时候手伸进背包，球是随机取出来的。通常用于计算平均值等对元素顺序没有要求的算法。

**队列**：一种先进先出的数据结构，代码见：`com.fzk.adt.Queue<E>`

**栈**：一种后进先出的数据结构，代码见：`com.fzk.adt.Stack<E>`

注，这里队列和栈的代码都是利用链表实现的。

 

应用：

**算术表达式求值**：利用Dijkstra的双栈求值法。

主要思路：一个栈存储操作符，另一个栈存储计算的数字。

遇到数字就压入数字栈，遇到四则运算符就压入操作符栈，遇到右括号就弹出两个数字栈栈顶元素和操作符栈顶元素，进行计算，并压入栈。直到字符串读取完成，停止循环。

最后为了防止连加连减等情况出现，要将栈中剩余元素进行计算。

具体讲解见1.3.1.7节，算术表达式求值。

代码见：`com.fzk.util.StringUtil.calculate(String)`

 

**链表**：本处实现了双向循环链表，与`java.util.LinkedList<E>`类似。

写出链表之后，可以轻松的利用链表来实现背包、队列、堆栈的功能。

代码见：`com.fzk.adt.LinkedList<E>`

 

tips：

**宽接口与窄接口**：在接口设计（尤其是底层代码，如数据结构的接口设计）中，我们经常会遇到“要不要这个功能”的问题。这里我们要尽量遵守一个原则：根据类的功能定义接口。不要想到什么功能就一股脑往里面添加。

比如设计jdk中的Stack，只需要实现堆栈的基本功能就可以了，但要是为了类的“多功能”，而实现了向栈底插入元素等队列的功能，这个类就会显得不伦不类。

 

我们尽量保持窄接口，是因为窄接口可以让我们清楚地明白类的功能和特性（如栈就只有入栈和出栈），限制用例的行为，使用例代码更加易懂。还有一点就是性能问题：宽接口无法保证高效的实现所有接口。

 

// TODO 练习：1.3.30 双向链表的就地逆置，代码没看懂！递归、非递归形式

// TODO 练习：1.3.50 快速出错的迭代器。利用计数器实现

## 1.4 算法分析

要评价一个算法的好坏，主要看它的执行时间。比如ThreeSum问题，最容易想到的是进行三遍循环（当然还有更好的方法），那么它的运行时间是~$aN^3$。其中“~”表示与哪个数量级近似，小于该数量级的则省略；$a$表示常数，这个常数取决于计算机性能。

进行算法分析的一个好处在于，它把“算法”和“算法的实现”隔离开来。也就是说，只要算法确定了，不论是在微型计算机还是在大型计算机上，它们的算法复杂度是相同的。

特别注意，$lgN$是以2为底，而不是数学上习惯的以10为底数，因为在分析复杂度只需要精确到数量级，对于log来说底数是任何大于1的有理数都没有差别，以2为底数只是方便计算而已。

常见的增长数量级：

| 描述     | 数量级    | 算法   |   举例 |
| :----- | ------ | :--- | ---: |
| 常数级别   | $1$    | 普通语句 | 堆栈操作 |
| 对数级别   | $lgN$  | 二分策略 | 二分查找 |
| 线性级别   | $N$    | 单次循环 | 元素搜索 |
| 线性对数级别 | $NlgN$ | 分治策略 | 归并排序 |
| 平方级别   | $N^2$  | 双层循环 | 插入排序 |
| 立方级别   | $N^3$  | 三层循环 |    - |
| 指数级别   | $2^N$  | 穷举查找 |    - |

 

一个小概念：下界。下界是指一个算法在最坏情况下的时间复杂度。比如2-sum问题的下界就是$NlgN$，3-sum问题的下界是$N^2$，K-sum问题的下界是$N^{K-1}(K\geq3)$。

2-sum问题，代码见：`com.fzk.util.ArrayUtil.twoSum(int[], int)`

3-sum问题，代码见：`com.fzk.util.ArrayUtil.threeSum(int[], int)`

 

在估算算法性能时，有几点可能引起估算不准确：

* 大常数：比如对一个算法的估算是$2N^2+cN$，我们通常会简化为$N^2$。这里有一个隐藏的前提条件，即常数$c$很小。但当$c=10000$甚至更大时，显然模型就不准确了。
* 非决定性内循环。
* 指令时间：每条指令执行的时间不一定完全相同。
* 系统因素：与计算机性能、网络连接有关。
* 不分伯仲：程序在某些场景很快，在特殊场景下又很慢。
* 对输入的强烈依赖：最好情况下复杂度是常数级别，最坏就没边了。
* 多个问题参量。

## 1.5 案例研究：union-find算法

// TODO 完全看不懂。。。



# 第二章 排序

## 2.1 初级排序算法

### 2.1.1 游戏规则

评判一种排序算法的优劣，可以通过以下两个方面：

1. 运行时间

排序成本模型：在研究排序算法时，我们需要计算“比较”和“交换”的数量。对于不交换元素的算法，我们会计算“访问数组”的次数。

2. 额外的内存使用

根据是否需要占用额外存储空间，可以将排序算法分为：就地排序算法和其他排序算法。

### 2.1.2 选择排序

**主要思想**：循环数组，找出最小的，与第一个元素交换（当第一个元素就是最小的时候，与自己交换）；找出第二小的，与第二个元素交换...直到循环整个数组。



**复杂度**：~$\frac{N^2}{2}$



**算法特点**：

* 运行时间与输入无关。即无论输入是有序数组还是乱序数组，比较次数是完全一样的；
* 复杂度较高；
* 是一种就地排序算法。

代码见：`com.fzk.util.SortUtil.selectionSort(int[])`

### 2.1.3 插入排序

**主要思想**：把数组分为两个区域：左边为有序区，右边为无序区。循环数组，每次取无序区的第一个，插入到有序区中的相应位置上去，比它大的元素各后移一位。直到整个数组都变为有序区为止。

 

**复杂度**：

* 最好情况下（输入数组严格有序），需要$N-1$次比较，$0$次插入；
* 最坏情况下（输入数组严格逆序），需要~$\frac{N^2}{2}$次比较，~$\frac{N^2}{2}$次插入；
* 平均情况下，需要~$\frac{N^2}{4}$次比较，~$\frac{N^2}{4}$次插入。



**算法特点**：

* 输入数组的好坏对算法效率影响很大；
* 适用于部分有序的数组（每个元素离它的最终位置都不远）；
* 是一种就地排序算法。



代码见：`com.fzk.util.SortUtil.insertionSort(int[])`

### 2.1.6 希尔排序

**主要思想**：多次插入排序。设定步长h，第一步使数组中任意间隔为h的元素都是有序的，形成一个h有序数组。下一步缩小步长为h/2，使数组成为一个h/2有序数组...h最后为1，对整个数组进行插入排序。

 

希尔排序是插入排序的改良版。插入排序只能一个一个元素的移动，这样效率会很慢。

 

第一步，分组。希尔排序会首先设定一个“步长”h，把索引为0,h,2h...这些元素看做一组，把索引为1,h+1,2h+1...这些元素也看做一组，以此类推。如下图所示：

![wpsB0E6.tmp.jpg](https://ooo.0o0.ooo/2017/01/01/5868fa84b255d.jpg) 

这张图表示，当数组长度为10，步长h为5时的分组情景。共分为5组（ABCDE组）。

第二步，组内排序。在每组内分别进行插入排序，如上图进行一轮组内排序后得到结果如下图。希尔排序相比直接插入排序的效率提升极大，关键就在这一步组内排序！

![wpsB0E7.tmp.jpg](https://ooo.0o0.ooo/2017/01/01/5868fa84c707b.jpg) 

第三步，缩小步长。缩小步长后重复组内排序，直到步长变为1。一般缩小步长的算法可以直接将原步长除以2。上图继续缩小步长为2，则下一次的组内排序变为下图：

![wpsB0E8.tmp.jpg](https://ooo.0o0.ooo/2017/01/01/5868fa84c9d23.jpg) 

继续缩小步长为1，如下图：

![wpsB0F8.tmp.jpg](https://ooo.0o0.ooo/2017/01/01/5868fc7845265.jpg) 

进行完步长h为1的时候，希尔排序宣告完成。

 

**算法分析**：希尔排序的关键就在于，组内排序！传统的插入排序要向有序区中间插入一个数字，只能把大于插入数字的所有元素都往后移动一位。这样太慢了！

希尔排序的做法是，首先分组，进行组内排序。第一次组内排序不要求元素一定在最终的位置上，但能保证进行一次组内排序后，每个元素都向最终的位置靠近了！

这样进行多轮组内排序，就可以完成整个算法的排序。

 

希尔排序选择插入排序做组内排序算法的原因在于，插入排序有一个极大的优点：输入数组越是接近有序，排序速度越快！最好情况可达到线性的复杂度。

而不断组内排序，就构造了一个这样的环境：数组变得越来越接近有序。这样可以让插入排序发挥它的优势。

 

> 通过提升速度来解决其他方式无法解决的问题，是研究算法的设计和性能的主要原因之一。
>
> ——名人名言

 

**复杂度**：当使用的递增序列为$3h+1$时（即1,4,13,40,121...，见代码），最坏情况下，比较次数与~$N^{\frac{3}{2}}$成正比。

使用不同的递增序列，比较的次数会各不相同，但都会小于直接插入排序的~$N^{2}$。

 

代码见：`com.fzk.util.SortUtil.shellSort(int[])`

参考链接：[白话经典算法：希尔排序](http://blog.csdn.net/morewindows/article/details/6668714)

## 2.2 归并排序

**主要思想**：递归，合并。

假如原数组长度为$n$，先排序左半部分（$0$ ~ $\frac n 2$），再排序右半部分（$\frac n 2+1$ ~ $n-1$）。最后将这两个子数组合并。

其中两个对子数组的排序用的也是归并排序，这就体现出递归的思想。

归并排序还包含了一个重要的思想：分治思想。

 

**复杂度**：时间复杂度：假设原数组长度为$N$，那么需要递归$n=lgN$次。想象成树形结构，那么这棵树有$n$层。则第k层共有$2^k$个子数组，每一个子数组的长度是$2^{n-k}$，则第$k$层要比较$2^{n-k} \times 2^k=2^n$次。则每层比较的次数与层数无关。那么一共$n$ 层，共需要比较$n \times 2^n=NlgN$次。因此归并排序的时间复杂度为~$NlgN$。

空间复杂度：需要一个与原数组长度相同的辅助数组，因此空间复杂度是~$N$。

 

**算法优化**：

1. 用插入排序代替小数组的归并。由于归并排序是一种递归算法，因此对于递归到很小的数组（比如长度为2的子数组）时仍然使用归并排序，这样对效率略有损耗。这时对小数组采用简单的插入排序，效率会略有提升。
2. 在融合之前，判断一下数组是否已经有序。当满足条件`arr[mid] <= arr[mid+1]`的条件时，说明数组已经有序，不需要融合了。因此添加这个判断后，对于严格有序的（子）数组，可以达到线性级别的复杂度。
3. 不要复制到辅助数组。由于每次融合都经历了“从原数组融合到辅助数组，再从辅助数组复制回原数组”的过程，这样比较浪费时间。我们可以在递归调用的每个层次交换原数组和辅助数组的角色，以节省复制所有元素的时间。
4. 多路归并。普通的归并排序是把数组分为两份，分别对每个子数组归并，然后再融合。现在可以首先分成三份，进行三向归并。



**一些题外话**：数学可证，没有任何基于比较的算法能够保证使用少于~$NlgN$次比较将长度为$N$的数组排序。而又可以证明，对于任意长度为$N$的数组，归并排序在最差情况下需要访问数组$6NlgN$次。基于以上两点，可以得出结论：归并排序是一种渐进最优的基于比较排序的算法。

 所以，不要费尽心思寻找小于$NlgN$的比较排序算法啦，找不到的！

代码见：`com.fzk.util.SortUtil.mergeSort(int[])`

## 2.3 快速排序

**主要思想**：分治策略。

选择一个基准数（pivot），第一趟循环让所有小于pivot的值放在左边，大于pivot的值放在右边，而pivot放在最终位置。

接着递归排序左边、右边即可。

 

**算法优化**：

1. 切换到插入排序。大多数的递归算法，改进算法性能有以下原则：对于小数组，递归排序要比直接插入排序慢。因此当要排序数组很小的时候，可以替换为插入排序。这样第一提高了速度，第二减少了递归深度。
2. 三取样切分。由于一开始的基准数（pivot）是随意取的，因此很有可能取到最大或最小值。以下办法可以改进：在数组中任意取3个数，并计算它们的中位数，把这个中位数当成基准数。这种方法称为三取样切分。
3. 熵最优的排序。实际中经常会出现含有大量重复元素的数组。这是，一个元素全部重复的子数组就不需要继续排序了。

## 2.4 优先队列

**简介**：优先队列是一种这样的抽象数据类型：它可以存储一组对象数据，主要提供以下方法：

1. 增加一个元素；
2. 删除并返回最大元素。

若用普通的顺序结构或链表结构，也能完成这样的需求，但要么插入的复杂度是~$N$，要么删除的复杂度是~$N$。

现在使用优先队列，可以使插入和删除操作的复杂度都变为$lgN$。

 

**数据结构**：二叉堆。

二叉堆在结构上类似于完全二叉树，但最主要的不同是，二叉堆是用顺序结构（数组）存储的，而二叉树是用二叉链表结构存储的。

由于结构上是一棵“完全二叉树”，才会选择用数组存储数据。我们可以很轻松的计算出一个节点的左右子节点和父节点在数组的位置。

比如根节点在位置$1$（索引为0的位置为空），那么索引为$k$的元素的左节点在$2k$，右节点在$2k+1$，父节点在$\lfloor \frac k 2 \rfloor$。

 

 

 

 

 

 

 













 

 # 备注

[一些奇形怪状的数学符号](http://blog.csdn.net/zcf1002797280/article/details/51289555)